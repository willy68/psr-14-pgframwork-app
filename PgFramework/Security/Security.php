<?php

declare(strict_types=1);

namespace PgFramework\Security;

use Exception;
use PgFramework\Environnement\Environnement;

use function base64_encode;
use function chr;
use function ord;
use function random_bytes;
use function strlen;

class Security
{
    /**
     * @var int
     */
    public const TOKEN_VALUE_LENGTH = 16;

    /**
     * Tokens have an hmac generated so we can ensure
     * that tokens were generated by our application.
     *
     * Should be TOKEN_VALUE_LENGTH + strlen(hmac)
     *
     * We are currently using sha1 for the hmac which
     * creates 40 bytes.
     *
     * @var int
     */
    public const TOKEN_WITH_CHECKSUM_LENGTH = 56;

    /**
     * Last token created
     */
    protected static string $lastToken;

    /**
     * Create a random password
     *
     * @param int $length
     * @return string
     * @throws Exception
     */
    public static function randomPassword(int $length): string
    {
        return substr(
            bin2hex(Security::randomBytes((int)ceil($length / 2))),
            0,
            $length
        );
    }

    /**
     * @throws Exception
     */
    public static function randomBytes(int $length): string
    {
        return random_bytes($length);
    }

    /**
     * @throws Exception
     */
    public static function generateId(int $length = 8): string
    {
        return bin2hex(Security::randomBytes($length));
    }

    /**
     * Get a salt from Environnement variable
     *
     * @return string|null
     * @throws Exception
     */
    public static function getSalt(): ?string
    {
        return Environnement::getEnv('APP_KEY', Security::randomBytes(Security::TOKEN_VALUE_LENGTH));
    }

    /**
     * Create a new token to be used for CSRF protection
     *
     * @param int $length random bytes length default 16
     * @return string length = 40 (hash_hmac sha1) + $length (default 16) = 56
     * @throws Exception
     */
    public static function createToken(int $length = Security::TOKEN_VALUE_LENGTH): string
    {
        $value = Security::randomBytes($length);

        static::$lastToken = base64_encode($value . hash_hmac('sha1', $value, static::getSalt()));

        return static::$lastToken;
    }

    public static function getLastToken(): string
    {
        return static::$lastToken;
    }

    /**
     * Apply entropy to a CSRF token
     *
     * To avoid BREACH apply a random salt value to a token
     * When the token is compared to the session the token needs
     * to be unsalted.
     *
     * @param string $token The token to salt.
     * @return string The salted token with the salt appended.
     * @throws Exception
     */
    public static function saltToken(string $token): string
    {
        $decoded = base64_decode($token, true);
        $length = strlen($decoded);
        $salt = Security::randomBytes($length);
        $salted = '';
        for ($i = 0; $i < $length; $i++) {
            // XOR the token and salt together so that we can reverse it later.
            $salted .= chr(ord($decoded[$i]) ^ ord($salt[$i]));
        }

        return base64_encode($salted . $salt);
    }

    /**
     * Remove the salt from a CSRF token.
     *
     * If $length / 2 !== $expectedLenght $token is not salted token
     *
     * @param string $token The token that could be salty.
     * @param int $expectedLenght
     * @return string An unsalted token.
     */
    public static function unsaltToken(
        string $token,
        int $expectedLenght = Security::TOKEN_WITH_CHECKSUM_LENGTH
    ): string {
        $decoded = base64_decode($token, true);
        $length = strlen($decoded) / 2;
        if ($length !== $expectedLenght) {
            return $token;
        }

        $salted = substr($decoded, 0, $length);
        $salt = substr($decoded, $length);

        $unsalted = '';
        for ($i = 0; $i < $length; $i++) {
            // Reverse the XOR to desalt.
            $unsalted .= chr(ord($salted[$i]) ^ ord($salt[$i]));
        }

        return base64_encode($unsalted);
    }


    /**
     * Verify that CSRF token was originally generated by the receiving application.
     *
     * @param string $token The unsalted CSRF token.
     * @param int $length Length from Security::createToken default to 16
     * @return bool
     * @throws Exception
     */
    public static function verifyToken(string $token, int $length = Security::TOKEN_VALUE_LENGTH): bool
    {
        $decoded = base64_decode($token, true);

        if (strlen($decoded) <= $length) {
            return false;
        }

        $key = substr($decoded, 0, $length);
        $hmac = substr($decoded, $length);

        $expectedHmac = hash_hmac('sha1', $key, Security::getSalt());

        return hash_equals($hmac, $expectedHmac);
    }
}
